{
    "My Cp template": {
        "prefix": "cp",
        "body": [
            "/*",
            "  Created by: Amit Kumar at $CURRENT_HOUR:$CURRENT_MINUTE on $CURRENT_DATE $CURRENT_MONTH_NAME_SHORT $CURRENT_YEAR_SHORT",
            "*/",
            "#include <bits/stdc++.h>",
            "#ifdef LOCAL",
            "#include \"debug.h\"",
            "#else",
            "#define db(...)",
            "#endif",
            "using namespace std;",
            "",
            "#define all(x) x.begin(),x.end()",
            "",
            "inline constexpr int MAXN = 2e5 + 1;",
            "inline constexpr int mod = 1e9 + 7;",
            "",
            "void solve()",
            "{",
            "  $0 ",
            "}",
            "int32_t main()",
            "{",
            "#ifdef LOCAL",
            "    freopen(\"input.txt\", \"r\", stdin);",
            "    freopen(\"output.txt\", \"w\", stdout);",
            "    auto started = std::chrono::high_resolution_clock::now();",
            "#endif",
            "",
            "    ios_base::sync_with_stdio(0);",
            "    cin.tie(0);",
            "    cout.tie(0);",
            "    int t;",
            "    t = 1;",
            "    $1cin >> t;",
            "    for (int I = 1; I <= t; I++)",
            "    {",
	        "	#ifdef LOCAL",
            "cerr << \"Case #\" << I << \": \";",
            "#endif",
            "    solve();",
            "    }",
            "#ifdef LOCAL",
            "auto done = std::chrono::high_resolution_clock::now();",
            "cerr << \"Time = \" << std::chrono::duration_cast<std::chrono::milliseconds>(done - started).count() << \" ms\\n\";",
            "#endif",
            "return 0;",
            "}"
        ],
        "description": "My Cp template"
    },
    "power": {
        "prefix": "pw",
        "body": [
            "long long power(long long x, long long y)",
            "{",
            "    long long res = 1;",
            "    x = x % mod;",
            "    while (y > 0)",
            "    {",
            "        if (y & 1)",
            "            res = (res * x) % mod;",
            "        y = y >> 1;",
            "        x = (x * x) % mod;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "power"
    },
    "policy based Data Structure": {
        "prefix": "pol",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "",
            "typedef tree<",
            "int, //key type",
            "null_type, // null_type for set,mapped for map",
            "less_equal<int>, // comparator",
            "rb_tree_tag, // tag denoting tree structure but not used for map",
            "tree_order_statistics_node_update>",
            "ordered_set;",
            "//1)find_by_order(k) returns element at index k (zero indexed)",
            "//2)order_of_key(element) returns the number of elements strictly smaller than element",
        ],
        "description": "Policy based Data Structure"
    },
    "for": {
        "prefix": "f",
        "body": [
            "for (size_t ${1:i} = ${2:0}; ${1:i} < ${3:length}; ${1:i}++)",
            "{",
            "$4",
            "}"
        ],
        "description": "Code snippet for 'for' loop"
    },
    "forr": {
        "prefix": "forr",
        "body": [
            "for (int ${1:i} = ${2:length} - 1; ${i} >= ${3:0}; ${i}--)",
            "{",
            "$4",
            "}"
        ],
        "description": "Code snippet for reverse 'for' loop"
    },
    "cinfor": {
        "prefix": "ifor",
        "body": [
            "for (size_t ${1:i} = ${2:0}; ${i} < ${3:length}; ${i}++)",
            "{",
            "cin>>$4[${i}];",
            "}"
        ],
        "description": "Code snippet for 'for' loop"
    },
    "pair of ints": {
        "prefix": "pii",
        "body": [
            "pair<int,int>"
        ],
        "description": "Code snippet for pair of ints"
    },
    "pair of long long": {
        "prefix": "pll",
        "body": [
            "pair<long long,long long>"
        ],
        "description": "Code snippet for pair of long longs"
    },
    "ncr": {
        "prefix": "ncr",
        "body": [
            "vector<long long > fact(MAXN);",
            "vector<long long > inv_fact(MAXN);",
            "",
            "void build_fact()",
            "{",
            "    fact[0] = 1;",
            "    for (long long  i = 1; i < MAXN; i++)",
            "    {",
            "        fact[i] = (i * fact[i - 1]) % mod;",
            "    }",
            "    inv_fact[MAXN - 1] = power(fact[MAXN - 1], mod - 2);",
            "    for (long long  i = MAXN - 2; i >= 0; i--)",
            "    {",
            "        inv_fact[i] = ((i + 1) * inv_fact[i + 1]) % mod;",
            "    }",
            "}",
            "long long  ncr(long long  n, long long  r)",
            "{",
            "    static bool built = false;",
            "    if (!built)",
            "    {",
            "        build_fact();",
            "        built = true;",
            "    }",
            "    if (n < r)",
            "       return 0;",
            "     if (n < 0 || r < 0)",
            "       return 0;",
            "    return (((fact[n] * inv_fact[r]) % mod) * (inv_fact[n - r])) % mod;",
            "}"
        ],
        "description": "ncr"
    },
    "Print container": {
        "prefix": "coutcont",
        "body": [
            "template <typename Ostream, typename Cont>",
            "inline typename enable_if<is_same<Ostream, ostream>::value, Ostream &>::type operator<<(Ostream &os, const Cont &v)",
            "{",
            "    for (auto &x : v)",
            "        os << x << \" \";",
            "    return os;",
            "}"
        ],
        "description": "Print container"
    },
    "take vector input": {
        "prefix": "cinvector",
        "body": [
            "template <typename Istream, typename T>",
            "inline typename enable_if<is_same<Istream, istream>::value, Istream &>::type operator>>(Istream &is, vector<T> &A)",
            "{",
            "    for (int i = 0; i < A.size(); i++)",
            "        is >> A[i];",
            "    return is;",
            "}"
        ],
        "description": "take vector input"
    },
    "print pair": {
        "prefix": "coutpair",
        "body": [
            "template <typename Ostream, typename X, typename Y>",
            "inline typename enable_if<is_same<Ostream, ostream>::value, Ostream &>::type operator<<(Ostream &os, pair<X, Y> const &p)",
            "{",
            "    return os << p.first << \" \" << p.second;",
            "}"
        ],
        "description": "print pair"
    },
    "Taking pair input": {
        "prefix": "cinpair",
        "body": [
            "template <typename Istream, typename X, typename Y>",
            "inline typename enable_if<is_same<Istream, istream>::value, Istream &>::type operator>>(Istream &is, pair<X, Y> &A)",
            "{",
            "    is >> A.first >> A.second;",
            "    return is;",
            "}",
        ],
        "description": "Taking pair input"
    },
    "N Dimensional vector": {
        "prefix": "Nvector",
        "body": [
            "template <int D, typename T>",
            "struct Vector : public vector<Vector<D - 1, T>>",
            "{",
            "static_assert(D >= 1, \"Vector dimension must be greater than zero!\");",
            "template <typename... Args>",
            "Vector(int n = 0, Args... args) : vector<Vector<D - 1, T>>(n, Vector<D - 1, T>(args...))",
            "{",
            "}",
            "};",
            "template <typename T>",
            "struct Vector<1, T> : public vector<T>",
            "{",
            "Vec(int n = 0, const T &val = T()) : vector<T>(n, val)",
            "{",
            "}",
            "};",
        ]
    },
    "Matrix class": {
        "prefix": "matrices",
        "body": [
            "template <typename T = long long int>",
            "class matrix",
            "{",
            "    vector<vector<T>> mat;",
            "    int r, c;",
            "",
            "public:",
            "    matrix()",
            "    {",
            "        this->r = 0;",
            "        this->c = 0;",
            "    }",
            "    matrix(int r, int c)",
            "    {",
            "        this->r = r;",
            "        this->c = c;",
            "        mat.assign(r, vector<T>(c));",
            "    }",
            "",
            "    matrix(int r, int c, const T &val)",
            "    {",
            "        this->r = r;",
            "        this->c = c;",
            "        mat.assign(r, vector<T>(c, val));",
            "    }",
            "",
            "    matrix(int n)",
            "    {",
            "        this->r = this->c = n;",
            "        mat.assign(n, vector<T>(n));",
            "        for (int i = 0; i < n; i++)",
            "            mat[i][i] = (T)1;",
            "    }",
            "",
            "    matrix(vector<vector<T>> lst) : mat(lst), r(lst.size()), c(lst[0].size())",
            "    {",
            "        for (int i = 0; i < r; i++)",
            "            assert(this->mat[i].size() == c);",
            "    }",
            "",
            "    T sum()",
            "    {",
            "        T res = 0;",
            "        for (const auto &rows : mat)",
            "            for (const auto &cells : rows)",
            "            {",
            "                res = (res + cells);",
            "#ifdef MOD",
            "                res %= MOD;",
            "#endif",
            "            }",
            "        return res;",
            "    }",
            "",
            "    matrix operator+(const matrix &B)",
            "    {",
            "        assert(this->r == B.r && this->c == B.c);",
            "        matrix<T> X(r, c);",
            "        for (int i = 0; i < r; ++i)",
            "            for (int j = 0; j < c; ++j)",
            "            {",
            "                X[i][j] = (mat[i][j] + B[i][j]);",
            "#ifdef MOD",
            "                X[i][j] %= MOD;",
            "#endif",
            "            }",
            "        return X;",
            "    }",
            "",
            "    matrix operator-()",
            "    {",
            "        matrix<T> C(r, c, 0);",
            "        int i, j;",
            "        for (i = 0; i < r; i++)",
            "            for (j = 0; j < c; j++)",
            "            {",
            "                C[i][j] = -mat[i][j];",
            "#ifdef MOD",
            "                C[i][j] %= MOD;",
            "                if (C[i][j] < 0)",
            "                    C[i][j] += MOD;",
            "#endif",
            "            }",
            "",
            "        return C;",
            "    }",
            "",
            "    matrix operator*(const matrix &B)",
            "    {",
            "        assert(this->c == B.r);",
            "        matrix<T> X(r, B.c, 0);",
            "",
            "        for (int j = 0; j < B.c; ++j)",
            "            for (int k = 0; k < c; ++k)",
            "            {",
            "                T temp = B[k][j];",
            "                for (int i = 0; i < r; ++i)",
            "                {",
            "                    X[i][j] = X[i][j] + (mat[i][k] * temp);",
            "#ifdef MOD",
            "                    X[i][j] %= MOD;",
            "#endif",
            "                }",
            "            }",
            "",
            "        return X;",
            "    }",
            "    static matrix power(matrix A, long long y)",
            "    {",
            "        assert(A.r == A.c);",
            "        matrix<T> res(A.r);",
            "        while (y > 0)",
            "        {",
            "            if (y & 1)",
            "                res = (res * A);",
            "            y = y >> 1;",
            "            A = A * A;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    vector<T> &operator[](int i)",
            "    {",
            "        return mat.at(i);",
            "    }",
            "    const vector<T> &operator[](int i) const",
            "    {",
            "        return mat.at(i);",
            "    }",
            "",
            "    friend istream &operator>>(istream &in, matrix &M)",
            "    {",
            "        for (int i = 0; i < M.r; i++)",
            "            for (int j = 0; j < M.c; j++)",
            "                in >> M[i][j];",
            "",
            "        return in;",
            "    }",
            "    friend ostream &operator<<(ostream &out, const matrix &M)",
            "    {",
            "        for (int i = 0; i < M.r; i++)",
            "        {",
            "            for (int j = 0; j < M.c; j++)",
            "                out << M[i][j] << \" \";",
            "            out << \"\\n\";",
            "        }",
            "        return out;",
            "    }",
            "};"
        ],
        "description": "Matrix class"
    },
    "modular operations": {
        "prefix": "modular",
        "body": [
            "namespace Modular",
            "{",
            "    template <typename T, typename U>",
            "    inline void mod_add(T &a, const U &b)",
            "    {",
            "        a = (a + b) % mod;",
            "    }",
            "    template <typename T, typename U>",
            "    inline void mod_sub(T &a, const U &b)",
            "    {",
            "        a = (a - b + mod) % mod;",
            "    }",
            "    template <typename T, typename U>",
            "    inline void mod_mul(T &a, const U &b)",
            "    {",
            "        a = (1ll * a * b) % mod;",
            "    }",
            "};",
            "using namespace Modular;"
        ],
        "description": "modular operations"
    },
    "random generator": {
        "prefix": "rand",
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());"
        ],
        "description": "random generator"
    }
}